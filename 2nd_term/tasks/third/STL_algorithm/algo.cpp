/*
В каждом пункте необходимо использовать функции библиотеки <algrithm>, в некоторых -- лямбды. 

1. Заведите массив на 1000 случайных чиселел из равномерного распределения {0, 1, ... , 99}.
Необходимо импользовать при этом std::generate.
2. Этот исходный массив мы менять не будем. Создайте копию исходного массива, с которой вы и будете дальше работать. 
Несмотря на то, что конструктором копирования это сделать значительно удобнее, в этом упражнении используйте функции std::copy и std::back_inserter.
3. Перемешайте элементы в случайном порядке.
4. Отсортируйте их по убыванию.
5. Разверните массив.
6. Напишите assetr, который проверяет, что первый элемент получившегося массива равен минимальному элементу исходного массива.
7. Напишите assetr, который проверяет, что последний элемент получившегося массива равен максимальному элементу исходного массива.
8. Создайте массив permutation, заполненный последовательными целыми числами от 0 до 999.
9. Сделайте так, тобы он соответстваовал перестановке исходного массива, которая его сортирует.
Для этого нужно вызвать std::sort для массива permutation, в котором лямбда будет захватывать по ссылке исходный массив. Оператор "меньше" для сортировки индексов соответсвует сравнению элементов в исходном массиве.
10. Заведите пустой массив sorted. Примените функцию std::transform для массива перестановок, которая в результате получит сортированный исходный массив. Для этого вам снова нужно будет захватить по ссылке исходный массив и использовать функцию std::back_inserter.
11. Напишите assert, который проверяет, что sorted отсортирован.
12. Напоминаю, что массив, с которым вы работали в пунктах 2-7 тоже отсортированный исходный массив. Проверьте это, написав assert, сравнивающий этот массив с массивом sorted.
13. Теперь будем считать, сколько раз встречаются элементы в массиве. Используйте std::generate для генерации элементов массива counts, внутри которого  количество элементов будет считаться с помощью std::count для исходного массива.
14. Добавьте в лямбду из предыдущего пункта assert, который проверяет, что количество, вычесленное с помощью std::count для исходного массива равно разнице между std::upper_bound и std::lower_bound для сортированного массива.
15. Посчитайте сумму элементов в массиве counts. Напишите assert, который проверит, что она равна количеству сгенерированных чисел.
16. Выведете элементы отсортированного массива через пробел на экран.
*/
#include <algorithm>
#include <iostream>
#include <assert.h>
#include <vector>
#include <ctime>

using namespace std;

int gen()
{
	return rand() % 100;
}

inline bool cmp (const int a, const int b)
{
	return a > b;
}

struct c_unique {
  int current;
  c_unique(): current(0) {}
  int operator () () { return current++; }
};

int main()
{
	// 1. generate()
	srand(unsigned(time(0)));
	vector<int> _vec(1000);
	generate(_vec.begin(), _vec.end(), gen);
	// 2. copy(), back_inserter()
	vector <int> vec;
	copy(_vec.begin(), _vec.end(), back_inserter(vec));
	// 3. random_shuffle()
	random_shuffle(vec.begin(), vec.end());
	// 4. sort()
	sort(vec.begin(), vec.end(), cmp);
	// 5. reverse() 
	reverse(vec.begin(), vec.end());
	// 6. assert(), min_element()
//	assert(vec[0] == *(min_element(vec.begin(), vec.end())));
	// 7. assert(), max_element()
//	assert(vec[0] == *(max_element(vec.begin(), vec.end())));
	// 8. generate
	vector <int> permutation(1000);
	generate (permutation.begin(), permutation.end(), c_unique());
	
	return 0;
}
