// new, delete, аллокаторы
/* Виды памяти:
1. Статическая: 
а). Статическая:

int data[100];  - глобальный массив, статическая память
int main()
{
	...
}

b). Константная:

const char[] = "Hello, World!";
int main()
{
	...
}

2. Стек (автоматическая память) (обычно размер - 64 Кб):

void f (const int& x)
{
	...
}

int main()
{
	int a;
	f(a);
	...
}

STACK | a | &f | x | .. - до вызова f(a) (и во время вызова)
STACK | a | - после вызова f(a)

2. Динамическая (куча):

int main()
{
	vector<int> v;
	for (int i = 0; ...)
	{
		map<int, string> m;
	}
}

pool - выделение сразу куска побольше, а уже из него маленьких кусочков, которые нм нужны

swap - память на жёстком диске, начинает работать при фрагментированной оперативной памяти
-------------------------|----------------------------------------------------------
|  *динамичская память*  | *код* *константные данные* *статические данные* *стек*  |
-------------------------|----------------------------------------------------------

New и Delete

class A 
{
	int *a;
	float x;
	int data[100];
	A() { a = new int[50] }
};

A *a = new A();

В 32-битной ОС - своё количество памяти (int = 4 байта)
В 64-битной ОС - int = 8 байт (чтобы указатель мог охватить всю оперативную память)

malloc() - вернёт NULL, если память не выделилась
new - росит exception, если память не выделилась (bad_alloc) - никогда не вернёт NULL

new (адрес) A(); - placement new - положит A по адресу, который мы указали

1). size_t sz = sizeof(A);
2). Запрашиваем sz памяти;
3). Вызываем конструктор (и вызывается специальный размещающий конструктор)

Commit Or Rollback - тезис выделения памяти

При создании объекта создаются ещё его метаданные, 
в которых можно будет посмотреть его размер

1. 
void * operator new (size_t sz) 
{
	...
	return ::operator new (sz); // системный new
}

void operator delete (void *)
{
	...
	free(p);	
}

2.
// Кладём обект класса А по адресу p
void *p = malloc(sizeof(A)); // p указывает на метаданные
A *a = new (p) A(); // a указывает на начало самого объекта
a->~A();
free(p);

--------------------------------
A a();
vector <A> v;
v.push_back(a); == new(end) A(a); - обязательно нужен конструктор копирования у A (!)
---------------------------------------
New и delete для классов
class A
{
	static void * operator new (size_t sz)
	{
		...
	}
	
	static void operator delete (void* p)
	{
		...
	}
};

class B: public A
{
	...
};

B *b = new B();
*/
